// === START OF COMPLETE xocoflow_logic.js ===
// Version: 1.11 - Refined nodeCreated listener for size updates
// Includes: Core, Base Nodes, Custom Nodes, CodeMirror Editor Integration,
//           Local Image Node (with Input Resizing), Project Mgmt, History, Tabs,
//           Status Bar, Button Visibility, Keyboard Shortcuts, Execution Logic,
//           Propagation, Activation, Error Handling.
"use strict";

console.log("Xocoflow Script: Initializing (v1.11)...");

// --- Constants ---
const DRAWFLOW_CONTAINER_ID = "drawflow";
const MAX_HISTORY_STATES = 50;
const LOCALSTORAGE_NODES_KEY = 'xocoflowCustomNodeTypes';
const CORS_PROXY = 'https://api.allorigins.win/get?url='; // Consider making this configurable

// --- Application State ---
let editor;
let currentProjectName = 'proyecto_sin_titulo';
let selectedNodeId = null;
let historyStack = [];
let historyIndex = -1;
let customNodeTypes = {};
let copiedNodeData = null;
let nodeIntervals = {}; // Stores interval IDs for timed nodes { nodeId: [intervalId1, ...] }

// --- CodeMirror State ---
let codeMirrorEditor = null;
let currentlyEditingNodeId = null;
let codeMirrorContainer = null;

// --- DOM Element Cache ---
const drawflowElement = document.getElementById(DRAWFLOW_CONTAINER_ID);
// Control Buttons
const undoButton = document.getElementById('undo-button');
const redoButton = document.getElementById('redo-button');
const duplicateButton = document.getElementById('duplicate-button');
const copyButton = document.getElementById('copy-button');
const pasteButton = document.getElementById('paste-button');
const recalculateButton = document.getElementById('recalculate-button');
const lockButton = document.getElementById('lock-button');
const unlockButton = document.getElementById('unlock-button');
// Status Bar
const statusBar = document.getElementById('editor-status-bar');
const zoomLevelSpan = document.getElementById('zoom-level');
const nodePositionSpan = document.getElementById('node-position');
// Other UI
const searchInput = document.getElementById('node-search');
const nodesListContainer = document.querySelector('.nodes-list');
const fileInputElement = document.getElementById('file-input');
const moduleListElement = document.querySelector('.menu ul#module-tabs');
const nodeDefinitionModal = document.getElementById('nodeDefinitionModal');
const modalBackdrop = document.getElementById('modalBackdrop');
// CodeMirror Sidebar
const codeEditorSidebar = document.getElementById('code-editor-sidebar');
const codeMirrorElement = document.getElementById('codemirror-container');
const codeEditorSaveButton = document.getElementById('save-code-sidebar-btn');
const codeEditorCloseButton = document.getElementById('close-code-sidebar-btn');
const editingNodeIdSpan = document.getElementById('editing-node-id');
const codeEditorTitleSpan = document.getElementById('code-editor-title');

// --- Critical Initial Checks ---
function checkElement(id, isCritical = false, message = `Element #${id} not found.`) {
    const el = document.getElementById(id) || document.querySelector(id);
    if (!el) {
        const level = isCritical ? 'error' : 'warn';
        console[level](message);
        if (isCritical) {
            alert(`CRITICAL ERROR: ${message} App cannot start.`);
            throw new Error(message);
        }
    }
    return el;
}
checkElement(DRAWFLOW_CONTAINER_ID, true);
checkElement('.menu ul#module-tabs', true, 'Module tab container (ul#module-tabs) not found.');
checkElement('.nodes-list', true);
checkElement('#lock-button'); checkElement('#unlock-button');
checkElement('#editor-status-bar'); checkElement('#zoom-level'); checkElement('#node-position');
checkElement('#nodeDefinitionModal'); checkElement('#modalBackdrop');
checkElement('#code-editor-sidebar'); checkElement('#codemirror-container');
checkElement('#save-code-sidebar-btn'); checkElement('#close-code-sidebar-btn');
checkElement('#editing-node-id'); checkElement('#code-editor-title', false);

// Library checks
if (typeof Drawflow === 'undefined') { console.error("Drawflow library not loaded."); alert("CRITICAL ERROR: Drawflow library not found."); throw new Error("Drawflow library not found."); }
if (typeof CodeMirror === 'undefined') { console.warn("CodeMirror library not loaded. Advanced editing disabled."); }
if (typeof Swal === 'undefined') { console.warn("SweetAlert2 library not loaded. Using basic alerts/logs."); }

// --- Initialize Drawflow ---
try {
    editor = new Drawflow(drawflowElement);
    editor.reroute = true;
    editor.editor_mode = 'edit'; // Start in editable mode
    editor.zoom_max = 1.8;
    editor.zoom_min = 0.25;
    editor.zoom_value = 0.08;
    console.log("Drawflow instance created and configured.");
} catch (e) {
    console.error("Fatal error initializing Drawflow:", e);
    alert("Fatal error initializing the flow editor. Check console.");
    throw e;
}

// --- Base Node Definitions ---
const baseNodeDefinitions = {
    'texto': { name: 'texto', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-paragraph"></i> Texto</div><div class="box"><label>Contenido:</label><textarea df-content readonly style="height: 80px;" placeholder="..."></textarea><button type="button" class="edit-code-btn" onclick="openEditorForNode(event)"><i class="fas fa-edit"></i> Editar Contenido</button><p class="help-text">Edita en panel lateral.</p></div></div>`, cssClass: 'text-node', data: { content: '' } },
    'concatenar': { name: 'concatenar', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-link"></i> Concatenar</div><div class="box" style="text-align: center; font-size: 11px; color: #777; padding: 20px 5px;">Concatena entradas<br>(orden Y)<input type="hidden" df-result></div></div>`, cssClass: 'concatenate-node', data: { result: '' } },
    'mostrarPasar': { name: 'mostrarPasar', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-eye"></i> Mostrar y Pasar</div><div class="box"><label>Resultado:</label><textarea df-result readonly style="height: 60px; background-color: #f0f0f0; width:100%; box-sizing: border-box;"></textarea><button type="button" onclick="selectAllText(event)" style="margin-top: 5px;">Seleccionar Todo</button><p class="help-text">Muestra y pasa datos.</p></div></div>`, cssClass: 'display-node', data: { result: '' } },
    'nota': { name: 'nota', inputs: 0, outputs: 0, html: `<div> <div class="title-box"><i class="fas fa-sticky-note"></i> Nota</div> <div class="box"> <div class="color-picker"> <label for="note-color-select-${'id' + Math.random().toString(16).slice(2)}">Color:</label> <select id="note-color-select-${'id' + Math.random().toString(16).slice(2)}" df-notecolor onchange="changeNoteColor(event)"> <option value="#ffffcc">Amarillo</option> <option value="#ccffcc">Verde</option> <option value="#ffcccc">Rojo</option> <option value="#ccccff">Azul</option> <option value="#e0e0e0">Gris</option> </select> </div> <textarea df-notecontent oninput="handleNodeDataChange(event); updateCharacterCount(event)" style="height: 120px;" placeholder="Notas..."></textarea> <div class="text-info"> <span df-charcount>0</span> chars </div> </div> </div>`, cssClass: 'note-node', data: { notecontent: '', notecolor: '#ffffcc', charcount: '0' } },
    'imagen': { name: 'imagen', inputs: 0, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-image"></i> Imagen HTML</div><div class="box"><div style="margin-bottom: 8px;"><button type="button" onclick="selectImageFile(event)">Seleccionar Local</button><span df-filename></span></div><img df-previewsrc src="" alt="Previa" style="display: none;"><label>URL:</label><input type="text" df-imgsrc oninput="handleImageInputChange(event)"><label>Alt:</label><input type="text" df-imgalt oninput="handleImageInputChange(event)"><label>Ancho:</label><input type="text" df-imgwidth oninput="handleImageInputChange(event)" placeholder="100px"><label>Alto:</label><input type="text" df-imgheight oninput="handleImageInputChange(event)"><p class="help-text">Salida: <img></p><input type="hidden" df-outputhtml></div></div>`, cssClass: 'image-node', data: { filename: '', previewsrc: '', imgsrc: '', imgalt: '', imgwidth: '', imgheight: '', outputhtml: '' } },
    'cargarTexto': { name: 'cargarTexto', inputs: 0, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-file-upload"></i> Cargar Texto</div><div class="box"><button type="button" onclick="selectTextFile(event)">Sel. Archivo</button><span df-filename></span><p class="help-text">Carga txt, html, ...</p><textarea df-filecontent style="display: none;"></textarea></div></div>`, cssClass: 'load-text-node', data: { filename: '', filecontent: '' } },
    'guardarTexto': { name: 'guardarTexto', inputs: 1, outputs: 0, html: `<div><div class="title-box"><i class="fas fa-save"></i> Guardar Texto</div><div class="box"><label>Nombre:</label><input type="text" df-savename oninput="handleNodeDataChange(event)" value="output.txt"><label>Contenido:</label><textarea df-savecontent readonly style="height: 60px;"></textarea><button type="button" onclick="saveNodeContentToFile(event)"><i class="fas fa-download"></i> Guardar</button></div></div>`, cssClass: 'save-text-node', data: { savename: 'output.txt', savecontent: '' } },
    'url_input': { name: 'url_input', inputs: 0, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-link"></i> URL Input</div><div class="box"><label>URL:</label><input df-url type="url" oninput="handleNodeDataChange(event)" placeholder="https://"></div></div>`, cssClass: 'url-input-node', data: { url: '' } },
    'timer_fetch': { name: 'timer_fetch', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-cloud-download-alt"></i> Timer Fetch</div><div class="box"><label>URL:</label><input df-url type="url" oninput="handleNodeDataChange(event)" placeholder="URL..."><label>Intervalo(ms):</label><input df-interval type="number" value="60000" min="100" oninput="handleNodeDataChange(event)"><p class="help-text">Fetch cada intervalo. Input 1=URL.</p></div></div>`, cssClass: 'timer-fetch-node', data: { interval: 60000, url: '' } },
    'fetch_html': { name: 'fetch_html', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-bolt"></i> Fetch HTML</div><div class="box help-text" style="padding: 15px 5px;">Recibe URL (Input 1), dispara fetch. Salida: HTML.</div></div>`, cssClass: 'fetch-node', data: {} },
    'display_text': { name: 'display_text', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-file-alt"></i> Display Text</div><div class="box"><label>Recibido:</label><textarea df-display readonly style="height:100px;"></textarea></div></div>`, cssClass: 'display-text-node', data: { display: 'Esperando...' } },
    'loop': { name: 'loop', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-sync-alt"></i> Loop</div><div class="box"><label>Intervalo(ms):</label><input df-interval type="number" value="1000" min="50" oninput="handleNodeDataChange(event)"></div></div>`, cssClass: 'loop-node', data: { interval: 1000 } },
    'repeat': { name: 'repeat', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-redo-alt"></i> Repeat</div><div class="box"><label>Veces:</label><input df-count type="number" value="3" min="1" oninput="handleNodeDataChange(event)"></div></div>`, cssClass: 'repeat-node', data: { count: 3 } },
    'timer_download': { name: 'timer_download', inputs: 0, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-stopwatch"></i> Timer Trigger</div><div class="box"><label>Intervalo(ms):</label><input df-interval type="number" value="10000" min="100" oninput="handleNodeDataChange(event)"><p class="help-text">Dispara timestamp.</p></div></div>`, cssClass: 'timer-node', data: { interval: 10000 } },
    'download_file': { name: 'download_file', inputs: 1, outputs: 0, html: `<div><div class="title-box"><i class="fas fa-download"></i> Download File</div><div class="box"><label>Nombre:</label><input df-filename type="text" value="download.txt" oninput="handleNodeDataChange(event)"><p class="help-text">Descarga Input 1.</p><input type="hidden" df-contentfordownload></div></div>`, cssClass: 'download-node', data: { filename: 'download.txt', contentfordownload: '' } },
    'extract_value': { name: 'extract_value', inputs: 2, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-filter"></i> Extraer Valor</div><div class="box"><label class="help-text">Regex (Input 2):</label><input type="text" df-selector_received readonly placeholder="(Patrón)"><label>Resultado (de Input 1):</label><textarea df-result readonly style="height:60px;">(Texto)</textarea></div></div>`, cssClass: 'extract-value-node', data: { selector_received: '', result: '(Esperando)' } },
    'javascript_code': { name: 'javascript_code', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fab fa-js-square"></i> Código JS</div><div class="box"><label>Código:</label><textarea df-jscode readonly style="height: 100px;" placeholder="// ..."></textarea><button type="button" class="edit-code-btn" onclick="openEditorForNode(event)"><i class="fas fa-edit"></i> Editar</button><div class="node-buttons"><button type="button" onclick="executeJsNode(event)"><i class="fas fa-play"></i> Ejecutar</button><button type="button" onclick="resetJsNodeResult(event)"><i class="fas fa-redo"></i> Reset</button></div><label>Resultado:</label><textarea df-result readonly style="height: 60px;"></textarea></div></div>`, cssClass: 'javascript-code-node', data: { jscode: "return input;", result: '', lastInput: null } },
    'static_code_snippet': { name: 'static_code_snippet', inputs: 1, outputs: 1, html: `<div><div class="title-box"><i class="fas fa-code"></i> Código Estático</div><div class="box"><label>Código:</label><textarea df-codecontent readonly style="height: 120px;" placeholder="<!-- ... -->"></textarea><button type="button" class="edit-code-btn" onclick="openEditorForNode(event)"><i class="fas fa-edit"></i> Editar</button><p class="help-text">Bloque estático. Edita con panel.</p></div></div>`, cssClass: 'static-code-node', data: { codecontent: '' } },

    // --- LOCAL IMAGE NODE (v1.11 - Definition stable since v1.9) ---
    'local_image': {
        name: 'local_image',
        inputs: 0, outputs: 0,
        html: `
            <div>
                <div class="title-box"><i class="fas fa-image"></i> Imagen Local</div>
                <div class="box">
                    <button type="button" onclick="selectLocalImageFile(event)" style="width:100%; margin-bottom: 8px;"><i class="fas fa-upload"></i> Cargar Imagen</button>
                    <div class="image-preview-container" style="margin-bottom: 8px; border: 1px dashed #ccc; display: flex; align-items: center; justify-content: center; background-color: #f9f9f9; overflow: hidden;">
                        <img df-imagesrc src="" alt="Previa Imagen" style="display: none; max-width: 100%; max-height:100%; width:auto; height:auto; object-fit: contain;" />
                        <span class="placeholder-text" style="color: #aaa; font-size: 11px; text-align: center; padding: 10px;">No hay imagen</span>
                    </div>
                    <span df-filename style="font-size: 10px; color: #777; display: block; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="Nombre del archivo"></span>
                    <details style="margin-bottom: 8px;">
                        <summary style="font-size: 10px; cursor: pointer; color: #555; font-weight:bold;">Tamaño Imagen Interna</summary>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <div style="flex: 1;"><label style="font-size: 10px;">Ancho Img:</label><input type="text" df-imagewidth oninput="updateLocalImageStyle(event)" placeholder="100%" style="font-size:11px; height: 24px; padding: 2px 4px;"></div>
                            <div style="flex: 1;"><label style="font-size: 10px;">Alto Img:</label><input type="text" df-imageheight oninput="updateLocalImageStyle(event)" placeholder="auto" style="font-size:11px; height: 24px; padding: 2px 4px;"></div>
                        </div><p class="help-text" style="margin-top: 2px;">Imagen dentro del nodo (ej: 100%, 150px)</p>
                    </details>
                    <details open style="margin-bottom: 8px;">
                        <summary style="font-size: 10px; cursor: pointer; color: #555; font-weight:bold;">Tamaño Nodo Contenedor</summary>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <div style="flex: 1;"><label style="font-size: 10px;">Ancho Nodo:</label><input type="text" df-nodewidth oninput="updateLocalNodeSize(event)" placeholder="240px" style="font-size:11px; height: 24px; padding: 2px 4px;"></div>
                            <div style="flex: 1;"><label style="font-size: 10px;">Alto Nodo:</label><input type="text" df-nodeheight oninput="updateLocalNodeSize(event)" placeholder="auto" style="font-size:11px; height: 24px; padding: 2px 4px;"></div>
                        </div><p class="help-text" style="margin-top: 2px;">Nodo completo (ej: 300px, auto)</p>
                    </details>
                </div>
            </div>`,
        cssClass: 'local-image-node',
        data: { imagesrc: '', filename: '', imagewidth: '100%', imageheight: 'auto', nodewidth: '240px', nodeheight: 'auto' }
    },
    // --- END LOCAL IMAGE NODE ---
};
console.log("Base node definitions loaded:", Object.keys(baseNodeDefinitions).length);

// --- Helper Functions ---
function escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return '';
    return String(unsafe)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}
function showToast(icon, title, text = '', timer = 2000) { if (typeof Swal === 'undefined') { console.log(`Toast (${icon}): ${title} - ${text}`); return; } Swal.fire({ toast: true, position: 'bottom', icon: icon, title: title, text: text, showConfirmButton: false, timer: timer, timerProgressBar: true, didOpen: (toast) => { toast.addEventListener('mouseenter', Swal.stopTimer); toast.addEventListener('mouseleave', Swal.resumeTimer); } }); }
function getConnections(nodeId, ioType) { try { const node = editor.getNodeFromId(nodeId); const ports = ioType === 'input' ? node?.inputs : node?.outputs; if (!ports) return []; let connections = []; Object.values(ports).forEach(portInfo => { if (portInfo?.connections) { connections = connections.concat(portInfo.connections); } }); return connections; } catch (e) { console.error(`Error getConnections ${ioType} for ${nodeId}:`, e); return []; } }
function readField(nodeId, attr) { try { const node = editor.getNodeFromId(nodeId); const dataKey = attr.startsWith('df-') ? attr.substring(3) : attr; if (node?.data && dataKey in node.data) { return node.data[dataKey]; } const element = document.getElementById(`node-${nodeId}`); if (element) { const inputElement = element.querySelector(`[${attr}]`); if (inputElement) { return inputElement.value; } } } catch (e) { /* ignore */ } return null; }
function getMimeType(ext) { const m = { 'html': 'text/html;charset=utf-8','htm': 'text/html;charset=utf-8','css': 'text/css;charset=utf-8','js': 'application/javascript;charset=utf-8','json': 'application/json;charset=utf-8','xml': 'application/xml;charset=utf-8','txt': 'text/plain;charset=utf-8','csv': 'text/csv;charset=utf-8','md': 'text/markdown;charset=utf-8','jpg': 'image/jpeg','jpeg': 'image/jpeg','png': 'image/png','gif': 'image/gif','svg': 'image/svg+xml','pdf': 'application/pdf'}; return m[ext?.toLowerCase()] || 'application/octet-stream'; } // Added optional chaining for ext
function getNodeIdFromEvent(event) { try { const nodeElement = event.target.closest('.drawflow-node'); return nodeElement ? nodeElement.id.split('-')[1] : null; } catch (e) { console.error("Error in getNodeIdFromEvent:", e); return null; } }

// --- Node Specific UI Functions ---
function selectAllText(event) { try { const n = event.target.closest('.drawflow-node'); const t = n?.querySelector('textarea[df-result], textarea[df-display], textarea[df-savecontent]'); if (t) { t.select(); t.setSelectionRange(0, t.value.length); } } catch (e) { console.error("Error selectAllText:", e); } }
function selectImageFile(event) { try { const n = event.target.closest('.drawflow-node'); if (!n) return; const id = n.id.split('-')[1]; const i = document.createElement('input'); i.type = 'file'; i.accept = 'image/*'; i.onchange = (e) => { const f = e.target.files[0]; if (f) { const r = new FileReader(); r.onload = (le) => { try { editor.updateNodeDataFromId(id, { filename: f.name, previewsrc: le.target.result }); const s = n.querySelector('span[df-filename]'); if (s) s.textContent = ` ${f.name}`; const p = n.querySelector('img[df-previewsrc]'); if (p) { p.src = le.target.result; p.style.display = 'block'; } requestAnimationFrame(() => { generateImageHtml(id); }); } catch (updateErr) { console.error("Error updating node data after file load:", updateErr); } }; r.onerror = () => showToast('error', 'Error', 'Cannot read image file.'); r.readAsDataURL(f); } i.value = null; }; i.click(); } catch (e) { console.error("Error selectImageFile:", e); showToast('error', 'Error', 'Problem selecting image file.'); } }
function generateImageHtml(nodeId) { try { const n = editor.getNodeFromId(nodeId); if (!n || n.name !== 'imagen') return; const d = n.data; let h = '<img'; const s = d.imgsrc || d.previewsrc; if (s) h += ` src="${escapeHtml(s)}"`; h += ` alt="${escapeHtml(d.imgalt || '')}"`; if (d.imgwidth) h += ` width="${escapeHtml(d.imgwidth)}"`; if (d.imgheight) h += ` height="${escapeHtml(d.imgheight)}"`; h += '>'; if (d.outputhtml !== h) { editor.updateNodeDataFromId(nodeId, { outputhtml: h }); propagateData(nodeId, 'imagen', 'outputhtml', h); saveHistoryState(); } } catch (e) { console.error(`Error generateImageHtml ${nodeId}:`, e); } }
function handleImageInputChange(event) { try { const n = event.target.closest('.drawflow-node'); if (!n) return; handleNodeDataChange(event); requestAnimationFrame(() => { const id = n.id.split('-')[1]; const node = editor.getNodeFromId(id); if (!node || node.name !== 'imagen') return; const data = node.data; if (event.target.hasAttribute('df-imgsrc')) { const p = n.querySelector('img[df-previewsrc]'); if (p) { const s = data.imgsrc || data.previewsrc || ''; p.src = s; p.style.display = s ? 'block' : 'none'; } } generateImageHtml(id); }); } catch (e) { console.error("Error handleImageInputChange:", e); } }
function selectTextFile(event) { try { const n = event.target.closest('.drawflow-node'); if (!n) return; const id = n.id.split('-')[1]; const i = document.createElement('input'); i.type = 'file'; i.accept = '.txt,.html,.css,.js,.json,.xml,text/*'; i.onchange = (e) => { const f = e.target.files[0]; if (f) { const r = new FileReader(); r.onload = (le) => { try { const c = le.target.result; editor.updateNodeDataFromId(id, { filename: f.name, filecontent: c }); const s = n.querySelector('span[df-filename]'); if (s) s.textContent = ` ${f.name}`; propagateData(id, 'cargarTexto', 'filecontent', c); saveHistoryState(); } catch(loadErr) { console.error("Error processing text file:", loadErr); } }; r.onerror = () => showToast('error', 'Error', 'Cannot read text file.'); r.readAsText(f); } i.value = null; }; i.click(); } catch (e) { console.error("Error selectTextFile:", e); showToast('error', 'Error', 'Problem selecting text file.'); } }
function saveNodeContentToFile(event) { try { const n = event.target.closest('.drawflow-node'); if (!n) return; const id = n.id.split('-')[1]; const node = editor.getNodeFromId(id); if (!node) return; let c='', fn='d.txt', df='', fnf=''; if (node.name === 'guardarTexto') { df='savecontent'; fnf='savename'; fn=node.data[fnf]?.trim()||'output.txt'; } else if (node.name === 'download_file') { df='contentfordownload'; fnf='filename'; fn=node.data[fnf]?.trim()||'download.html'; } else return; c=node.data[df]||''; if (!c && node.name !== 'download_file') { showToast('warning', 'Empty Content', 'Nothing to save.'); return; } fn=fn.replace(/[^a-zA-Z0-9._-]/g,'_').trim()||"d.txt"; if(fn.length>200) fn=fn.substring(0,200); const mime=getMimeType(fn.split('.').pop()); const b=new Blob([c],{type:mime}); const l=document.createElement('a'); l.href=URL.createObjectURL(b); l.download=fn; document.body.appendChild(l); l.click(); document.body.removeChild(l); URL.revokeObjectURL(l.href); } catch (error) { console.error("Error saveNodeContentToFile:", error); showToast('error', 'Save Error', 'Could not save file.'); } }
function updateCharacterCount(event) { try { const t = event.target; const n = t.closest('.drawflow-node'); if (!n || !t.hasAttribute('df-notecontent')) return; const c = t.value?.length || 0; const s = n.querySelector('[df-charcount]'); if (s) s.textContent = c; } catch (e) { console.error("Error updateCharacterCount:", e); } }
function changeNoteColor(event) { try { const s = event.target; const n = s.closest('.drawflow-node'); if (!n) return; const id = n.id.split('-')[1]; const c = s.value; editor.updateNodeDataFromId(id, { notecolor: c }); n.style.backgroundColor = c; saveHistoryState(); } catch (e) { console.error("Error changeNoteColor:", e); showToast('error', 'Color Error', 'Could not change note color.'); } }
function openEditorForNode(event) { try { const btn = event.target.closest('button.edit-code-btn'); const nEl = btn?.closest('.drawflow-node'); if (!nEl) return; const id = nEl.id.split('-')[1]; const node = editor.getNodeFromId(id); const types = ['javascript_code', 'static_code_snippet', 'texto']; if (id && types.includes(node?.name)) { editor.selectNode(nEl.id); } } catch(e) { console.error("Error openEditorForNode:", e); } }
function executeJsNode(event) { try{ event.stopPropagation(); const nEl = event.target.closest('.drawflow-node'); if (!nEl) return; const id = nEl.id.split('-')[1]; const node = editor.getNodeFromId(id); if (!node || node.name !== 'javascript_code') return; const code = node.data.jscode || ''; const input = node.data.lastInput; let res, err=false, resStr=''; const start = performance.now(); try { const func = new Function('input', `'use strict';\n${code}`); res = func(input); if (res === undefined) resStr = '(undefined)'; else if (res === null) resStr = 'null'; else if (typeof res === 'string') resStr = res; else try { resStr = JSON.stringify(res, null, 2); } catch { resStr = String(res); } const end = performance.now(); console.log(`JS Result (${(end - start).toFixed(1)}ms):`, res); } catch (e) { const end = performance.now(); console.error(`JS Error ${id} (${(end-start).toFixed(1)}ms):`, e); resStr=`Error: ${e.message}\n${e.stack?e.stack.split('\n')[1]:''}`; err=true; res=undefined; } const ta = nEl.querySelector('textarea[df-result]'); if (ta) { ta.value = resStr; ta.classList.toggle('error', err); } editor.updateNodeDataFromId(id, { result: res }); if (!err) propagateData(id, 'javascript_code', 'result', res); }catch(ex){ console.error("Outer error executeJsNode:", ex); } }
function resetJsNodeResult(event) { try{ event.stopPropagation(); const nEl = event.target.closest('.drawflow-node'); if (!nEl) return; const id = nEl.id.split('-')[1]; const node = editor.getNodeFromId(id); if (!node || node.name !== 'javascript_code') return; const ta = nEl.querySelector('textarea[df-result]'); if (ta) { ta.value = ''; ta.classList.remove('error'); } editor.updateNodeDataFromId(id, { result: '' }); propagateData(id, 'javascript_code', 'result', null); }catch(ex){ console.error("Outer error resetJsNodeResult:", ex); } }

// --- Functions for Local Image Node (v1.11 - Stable) ---
function selectLocalImageFile(event) { const nodeId = getNodeIdFromEvent(event); if (!nodeId || !editor) return; try { const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = 'image/*'; fileInput.onchange = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (loadEvent) => { try { const imageDataUrl = loadEvent.target.result; editor.updateNodeDataFromId(nodeId, { imagesrc: imageDataUrl, filename: file.name }); const nodeElement = document.getElementById(`node-${nodeId}`); if (nodeElement) { const imgTag = nodeElement.querySelector('img[df-imagesrc]'); const filenameSpan = nodeElement.querySelector('span[df-filename]'); const placeholderText = nodeElement.querySelector('.placeholder-text'); if (imgTag) { imgTag.src = imageDataUrl; imgTag.style.display = 'block'; const nodeData = editor.getNodeFromId(nodeId).data; imgTag.style.width = nodeData.imagewidth || '100%'; imgTag.style.height = nodeData.imageheight || 'auto'; } if (filenameSpan) { filenameSpan.textContent = file.name; filenameSpan.title = file.name; } if (placeholderText) { placeholderText.style.display = 'none'; } } saveHistoryState(); } catch (innerError) { console.error("Error processing loaded image:", innerError); showToast('error', 'Error Interno', 'No se pudo procesar la imagen.'); } }; reader.onerror = () => { showToast('error', 'Error de Lectura', 'No se pudo leer el archivo.'); }; reader.readAsDataURL(file); } fileInput.value = null; }; fileInput.click(); } catch (error) { console.error("Error selecting local image file:", error); showToast('error', 'Error', 'No se pudo iniciar selección.'); } }
function updateLocalImageStyle(event) { const nodeId = getNodeIdFromEvent(event); if (!nodeId || !editor) return; try { const nodeElement = document.getElementById(`node-${nodeId}`); if (!nodeElement) return; const imgTag = nodeElement.querySelector('img[df-imagesrc]'); const widthInput = nodeElement.querySelector('input[df-imagewidth]'); const heightInput = nodeElement.querySelector('input[df-imageheight]'); if (!imgTag || !widthInput || !heightInput) return; const newWidth = widthInput.value.trim() || 'auto'; const newHeight = heightInput.value.trim() || 'auto'; imgTag.style.width = newWidth; imgTag.style.height = newHeight; handleNodeDataChange(event); } catch (error) { console.error("Error updating local image style:", error); showToast('error', 'Error Estilo Imagen', 'No se pudo actualizar tamaño imagen.'); } }
function updateLocalNodeSize(event) { const nodeId = getNodeIdFromEvent(event); if (!nodeId || !editor) return; try { const nodeElement = document.getElementById(`node-${nodeId}`); if (!nodeElement) return; const widthInput = nodeElement.querySelector('input[df-nodewidth]'); const heightInput = nodeElement.querySelector('input[df-nodeheight]'); if (!widthInput || !heightInput) return; const newWidth = widthInput.value.trim() || 'auto'; const newHeight = heightInput.value.trim() || 'auto'; nodeElement.style.width = newWidth; nodeElement.style.height = newHeight; handleNodeDataChange(event); editor.updateConnectionNodes(`node-${nodeId}`); } catch (error) { console.error("Error updating local node size:", error); showToast('error', 'Error Tamaño Nodo', 'No se pudo actualizar tamaño nodo.'); } }
// --- END Local Image Node Functions ---

// --- Interval Management ---
function cleanupNodeIntervals(nodeId) { if (nodeIntervals[nodeId]) { nodeIntervals[nodeId].forEach(clearInterval); delete nodeIntervals[nodeId]; } }
function cleanupAllModuleIntervals() { const keys = Object.keys(nodeIntervals); if (keys.length > 0) { console.log(`Cleaning intervals for ${keys.length} nodes...`); keys.forEach(cleanupNodeIntervals); nodeIntervals = {}; } }

// --- Execution & Propagation ---
const EXECUTE_NODE_SYSTEM_TYPES = ['url_input', 'timer_fetch', 'fetch_html', 'display_text', 'loop', 'repeat', 'timer_download', 'download_file', 'extract_value'];
async function executeNode(nodeId, payload) { let node; try { node = editor.getNodeFromId(nodeId); if (!node) { cleanupNodeIntervals(nodeId); return; } } catch (error) { console.error(`Err get node ${nodeId}:`, error); return; } const nName = node.name; let outP = payload; if (node._executing) return; node._executing = true; try { switch (nName) { case 'timer_fetch': case 'timer_download': case 'loop': { cleanupNodeIntervals(nodeId); let intMs = parseInt(readField(nodeId, 'df-interval') || node.data?.interval, 10); const defInt = nName === 'loop' ? 1000 : (nName === 'timer_fetch' ? 60000 : 10000); if (isNaN(intMs) || intMs < 100) intMs = defInt; const initP = payload; console.log(`Start ${nName} ${nodeId} every ${intMs} ms.`); const execInt = async () => { try { const currN = editor.getNodeFromId(nodeId); if (!currN) { cleanupNodeIntervals(nodeId); return; } if (nName === 'timer_fetch') { let url = readField(nodeId, 'df-url'); if (!url?.trim()) { const cs = getConnections(nodeId, 'input'); for (const c of cs) { const src = editor.getNodeFromId(c.node); if (src?.name === 'url_input') { url = readField(c.node, 'df-url'); if (url?.trim()) break; } } } if (url?.trim()) { url = url.trim(); if (!url.startsWith('http')) url = 'https://' + url; try { const r = await fetch(CORS_PROXY + encodeURIComponent(url)); if (!r.ok) throw new Error(`HTTP ${r.status}`); const d = await r.json(); propagateExecution(nodeId, d.contents); } catch (err) { console.error(`TFetch ${nodeId} err:`, err); propagateExecution(nodeId, `// ERR Fetch:\n// ${err.message}`); } } else propagateExecution(nodeId, '// ERR: No URL'); } else if (nName === 'loop') { propagateExecution(nodeId, initP); } else propagateExecution(nodeId, Date.now()); } catch(intervalErr) { console.error(`Error inside interval for ${nName} ${nodeId}:`, intervalErr); cleanupNodeIntervals(nodeId); } }; const intId = setInterval(execInt, intMs); if (!nodeIntervals[nodeId]) nodeIntervals[nodeId] = []; nodeIntervals[nodeId].push(intId); if (nName === 'timer_fetch' && readField(nodeId, 'df-url')) { await execInt(); } break; } case 'fetch_html': { let url = payload; if (typeof url !== 'string' || !url?.trim()){ propagateExecution(nodeId, '// ERR: Invalid URL'); return; } url = url.trim(); if (!url.startsWith('http')) url = 'https://' + url; try { const r = await fetch(CORS_PROXY + encodeURIComponent(url)); if (!r.ok) throw new Error(`HTTP ${r.status}`); const d = await r.json(); outP = d.contents; } catch (err) { console.error(`Fetch ${nodeId} err:`, err); outP = `// ERR Fetch:\n// ${err.message}`; } propagateExecution(nodeId, outP); break; } case 'display_text': { const txt = String(payload ?? '(null)'); editor.updateNodeDataFromId(nodeId, { display: txt }); const el = document.getElementById(`node-${nodeId}`); const ta = el?.querySelector('textarea[df-display]'); if (ta) ta.value = txt; outP = payload; propagateExecution(nodeId, outP); break; } case 'repeat': { let c = parseInt(readField(nodeId, 'df-count') || node.data?.count, 10); if (isNaN(c) || c <= 0) return; const p = payload; for (let i = 0; i < c; i++) setTimeout(() => propagateExecution(nodeId, p), 0); return; } case 'download_file': { if (payload === null || payload === undefined) return; const f = readField(nodeId, 'df-filename')?.trim() || 'd.txt'; const s = String(payload); editor.updateNodeDataFromId(nodeId, { contentfordownload: s, filename: f }); try { const sf = f.replace(/[^a-zA-Z0-9._-]/g, '_').trim() || "d.txt"; const m = getMimeType(sf.split('.').pop()); const b = new Blob([s], { type: m }); const l = document.createElement('a'); l.href = URL.createObjectURL(b); l.download = sf; document.body.appendChild(l); l.click(); document.body.removeChild(l); URL.revokeObjectURL(l.href); } catch (err) { console.error(`Download ${nodeId} error:`, err); showToast('error', 'Error', 'Error descarga.'); } return; } case 'url_input': { const u = readField(nodeId, 'df-url'); outP = u; propagateExecution(nodeId, outP); break; } case 'extract_value': { const txt = String(payload ?? ''); const pat = readField(nodeId, 'df-selector_received') || ''; let val = null, res = '(Esperando)'; if (txt && pat) { try { const r = new RegExp(pat); const m = txt.match(r); if (m) { val = m[1] ?? m[0]; res = val; } else res = '(No encontrado)'; } catch (e) { res = '(Error Regex)'; } } else if (!pat) res = '(Esperando patrón)'; else res = '(Esperando texto)'; editor.updateNodeDataFromId(nodeId, { result: res }); const el = document.getElementById(`node-${nodeId}`); const rt = el?.querySelector('textarea[df-result]'); if (rt) rt.value = res; outP = val; propagateExecution(nodeId, outP); break; } default: { propagateExecution(nodeId, outP); } } } catch (error) { console.error(`Error executing ${nName} (${nodeId}):`, error); showToast('error', `Error ${nName}`, error.message.substring(0,50), 4000); } finally { if (node) node._executing = false; } }
function propagateExecution(sourceNodeId, payload) { try{ const conns = getConnections(sourceNodeId, 'output'); conns.forEach(conn => { try { const targetId = conn.node; const targetNode = editor.getNodeFromId(targetId); if (!targetNode) return; const targetPort = conn.input_class; const targetName = targetNode.name; if (EXECUTE_NODE_SYSTEM_TYPES.includes(targetName)) { if (targetName === 'extract_value') { if (targetPort === 'input_1') { setTimeout(() => executeNode(targetId, payload), 0); } else if (targetPort === 'input_2') { const s = String(payload ?? ''); editor.updateNodeDataFromId(targetId, { selector_received: s }); const el = document.getElementById(`node-${targetId}`); const i = el?.querySelector('input[df-selector_received]'); if (i) i.value = s; const currentText = readField(targetId, 'result'); if(currentText !== '(Esperando texto)') { setTimeout(() => executeNode(targetId, currentText), 0); } // Re-execute if text exists
                            } } else { setTimeout(() => executeNode(targetId, payload), 0); } } else if (targetName === 'javascript_code') { editor.updateNodeDataFromId(targetId, { lastInput: payload }); } else if (targetName === 'concatenar') { setTimeout(() => updateConcatenateNode(targetId), 0); } else if (targetName === 'mostrarPasar') { if (targetPort === 'input_1') { const v = String(payload ?? ''); editor.updateNodeDataFromId(targetId, { result: v }); const el = document.getElementById(`node-${targetId}`); const ta = el?.querySelector('textarea[df-result]'); if(ta) ta.value = v; setTimeout(() => propagateData(targetId, targetName, 'result', payload), 0); } } else if (targetName === 'guardarTexto') { if (targetPort === 'input_1') { const v = String(payload ?? ''); editor.updateNodeDataFromId(targetId, { savecontent: v }); const el = document.getElementById(`node-${targetId}`); const ta = el?.querySelector('textarea[df-savecontent]'); if(ta) ta.value = v; } } } catch (connError) { console.error(`Error processing connection from ${sourceNodeId} to ${conn.node}:`, connError); } }); } catch(outerError){ console.error(`Error in propagateExecution for ${sourceNodeId}:`, outerError); } }
function handleNodeDataChange(event) { if (!editor || !event?.target) return; const el = event.target; const nodeEl = el.closest('.drawflow-node'); if (!nodeEl) return; const id = nodeEl.id.split('-')[1]; const node = editor.getNodeFromId(id); if (!node) return; let key = null; for (const attr of el.attributes) { if (attr.name.startsWith('df-')) { key = attr.name.substring(3); break; } } if (!key) return; requestAnimationFrame(() => { try { const updatedNode = editor.getNodeFromId(id); if (!updatedNode) return; const dataKey = key; let val = el.value; if (el.type === 'checkbox') val = el.checked; else if (el.type === 'select-one') val = el.value; let newData = {}; newData[dataKey] = val; editor.updateNodeDataFromId(id, newData); const name = updatedNode.name; if ((name === 'url_input' && dataKey === 'url') || (name === 'cargarTexto' && dataKey === 'filecontent') || (name === 'texto' && dataKey === 'content') || (name === 'static_code_snippet' && dataKey === 'codecontent')) { propagateData(id, name, dataKey, val); } else if (name === 'imagen') { if (['imgsrc', 'imgalt', 'imgwidth', 'imgheight'].includes(dataKey)) { generateImageHtml(id); } } else if (name === 'nota' && dataKey === 'notecontent') { updateCharacterCount(event); } else if ((name === 'timer_fetch' || name === 'timer_download' || name === 'loop') && dataKey === 'interval') { executeNode(id, null); } else if (name === 'timer_fetch' && dataKey === 'url') { executeNode(id, null); } saveHistoryState(); } catch (e) { console.error(`Error handleNodeDataChange (${id}/${key}):`, e); } }); }
function propagateData(sourceNodeId, sourceNodeName, changedKey, outputData) { try { const sourceNode = editor.getNodeFromId(sourceNodeId); let outputPortKey = 'output_1'; const outputPort = sourceNode?.outputs?.[outputPortKey]; if (!outputPort) return; const connections = outputPort.connections || []; connections.forEach(conn => { try { const targetId = conn.node; const targetNode = editor.getNodeFromId(targetId); if (!targetNode) return; const targetPort = conn.input_class; const targetName = targetNode.name; if (EXECUTE_NODE_SYSTEM_TYPES.includes(targetName)) { if (targetName === 'extract_value') { if (targetPort === 'input_1') { setTimeout(() => executeNode(targetId, outputData), 0); } else if (targetPort === 'input_2') { const s = String(outputData ?? ''); editor.updateNodeDataFromId(targetId, { selector_received: s }); const el = document.getElementById(`node-${targetId}`); const i = el?.querySelector('input[df-selector_received]'); if (i) i.value = s; const currentText = readField(targetId, 'result'); if(currentText !== '(Esperando texto)' && currentText !== '(Esperando)') { setTimeout(() => executeNode(targetId, currentText), 0); } } } else { setTimeout(() => executeNode(targetId, outputData), 0); } } else if (targetName === 'javascript_code') { editor.updateNodeDataFromId(targetId, { lastInput: outputData }); } else if (targetName === 'concatenar') { setTimeout(() => updateConcatenateNode(targetId), 0); } else if (targetName === 'mostrarPasar') { if (targetPort === 'input_1') { const v = String(outputData ?? ''); editor.updateNodeDataFromId(targetId, { result: v }); const el = document.getElementById(`node-${targetId}`); const ta = el?.querySelector('textarea[df-result]'); if(ta) ta.value = v; setTimeout(() => propagateData(targetId, targetName, 'result', outputData), 0); } } else if (targetName === 'guardarTexto') { if (targetPort === 'input_1') { const v = String(outputData ?? ''); editor.updateNodeDataFromId(targetId, { savecontent: v }); const el = document.getElementById(`node-${targetId}`); const ta = el?.querySelector('textarea[df-savecontent]'); if(ta) ta.value = v; } } } catch (connError) { console.error(`Error propagating data from ${sourceNodeId} to ${conn.node}:`, connError); } }); } catch(outerError) { console.error(`Error in propagateData for ${sourceNodeId}, key ${changedKey}:`, outerError); } }
function updateConcatenateNode(nodeId) { try { const n = editor.getNodeFromId(nodeId); if (!n || n.name !== 'concatenar' || !n.inputs?.input_1) return; const conns = (n.inputs.input_1.connections || []).slice().sort((a, b) => (editor.getNodeFromId(a.output_id)?.pos_y ?? 0) - (editor.getNodeFromId(b.output_id)?.pos_y ?? 0)); let str = ""; conns.forEach(c => { const sN = editor.getNodeFromId(c.output_id); if (!sN?.data) return; let dC = undefined; const d = sN.data; const keys = ['result', 'content', 'codecontent', 'outputhtml', 'filecontent', 'display', 'url', 'jscode']; for(const k of keys){if(d.hasOwnProperty(k)){ dC = d[k]; break; }} if (dC === undefined && Object.keys(d).length > 0) { const validKeys = Object.keys(d).filter(k => !['lastInput', 'selector_received', 'filename', 'previewsrc', 'imagewidth', 'imageheight','nodewidth','nodeheight', 'notecontent', 'notecolor', 'charcount', 'savename', 'savecontent', 'contentfordownload'].includes(k)); if (validKeys.length > 0) dC = d[validKeys[0]]; } str += String(dC ?? ''); }); if (n.data.result !== str) { editor.updateNodeDataFromId(nodeId, { result: str }); propagateData(nodeId, 'concatenar', 'result', str); saveHistoryState(); } } catch(e) { console.error(`Error updating concatenate node ${nodeId}:`, e); } }

// --- Node Activation ---
function activateNodeIfNeeded(nodeId) { try { const node = editor.getNodeFromId(nodeId); if (!node) return; const nName = node.name; if (['timer_fetch', 'timer_download', 'loop'].includes(nName)) { executeNode(nodeId, null); } else if (nName === 'repeat' && getConnections(nodeId, 'input').length === 0) { executeNode(nodeId, null); } else if (nName === 'url_input') { const url = readField(nodeId, 'df-url'); if (url?.trim()) { executeNode(nodeId, url); } } else if (nName === 'cargarTexto') { const c = node.data?.filecontent; if(c) { propagateData(nodeId, nName, 'filecontent', c); } } else if (nName === 'texto') { const c = node.data?.content; if(c) { propagateData(nodeId, nName, 'content', c); } } else if (nName === 'static_code_snippet') { const c = node.data?.codecontent; if(c) { propagateData(nodeId, nName, 'codecontent', c); } } else if (nName === 'imagen') { generateImageHtml(nodeId); } } catch (error) { console.error(`Error activating ${nodeId}:`, error); } }
function activateExistingAutoNodes() { console.log("Activating initial/auto nodes..."); let nodes = {}; try { nodes = editor.export()?.drawflow?.[editor.module]?.data ?? {}; } catch (e) { console.error("Err get nodes for activation:", e); return; } cleanupAllModuleIntervals(); const ids = Object.keys(nodes); if (ids.length > 0) { ids.forEach(id => { activateNodeIfNeeded(id); }); ids.forEach(id => { if (nodes[id]?.name === 'concatenar') { updateConcatenateNode(id); } }); } console.log("Initial activation complete."); }

// --- Node Search ---
if (searchInput) searchInput.addEventListener('input', filterNodes);
function filterNodes() { if (!searchInput || !nodesListContainer) return; try { const s = searchInput.value.toLowerCase().trim(); const items = nodesListContainer.querySelectorAll('.drag-drawflow, .create-node-button-wrapper'); items?.forEach(i => { const btnWrapper = i.classList.contains('create-node-button-wrapper'); const isDragItem = i.classList.contains('drag-drawflow'); const type = isDragItem ? i.dataset.node?.toLowerCase() : ''; const nameEl = isDragItem ? i.querySelector('span') : null; const nameTxt = nameEl?.textContent.toLowerCase().trim() || ''; const defName = btnWrapper ? 'crear tipo nodo' : ''; const itemTxt = nameTxt || defName; const show = !s || itemTxt.includes(s) || (type && type.includes(s)) || (btnWrapper && 'crear'.includes(s)); i.style.display = show ? 'block' : 'none'; if (isDragItem) i.style.display = show ? 'flex' : 'none'; }); } catch (e) { console.error("Error filterNodes:", e); } }

// --- Custom Node Management ---
function getStoredCustomNodeTypes() { try { const s = localStorage.getItem(LOCALSTORAGE_NODES_KEY); return JSON.parse(s || '{}'); } catch (e) { console.error("Err reading custom types:", e); return {}; } }
function saveCustomNodeTypes(allTypes) { try { const custom = {}; for (const k in allTypes) if (!baseNodeDefinitions.hasOwnProperty(k)) custom[k] = allTypes[k]; localStorage.setItem(LOCALSTORAGE_NODES_KEY, JSON.stringify(custom)); } catch (e) { console.error("Err saving custom types:", e); showToast('error', 'Error', 'Cannot save custom nodes.'); } }
function addDraggableItemToSidebar(nodeDef) { if (!nodesListContainer || !nodeDef?.name) return; if (nodesListContainer.querySelector(`.drag-drawflow[data-node="${nodeDef.name}"]`)) return; const div = document.createElement('div'); div.className = 'drag-drawflow'; div.style.display = 'flex'; div.draggable = true; div.dataset.node = nodeDef.name; let title = nodeDef.title || nodeDef.name; let iconHtml = '<i class="fas fa-puzzle-piece fa-fw"></i>'; try { const tmp = document.createElement('div'); tmp.innerHTML = nodeDef.html || ''; const tb = tmp.querySelector('.title-box'); if (tb) { const i = tb.querySelector('i'); if (i) { const ci = i.cloneNode(true); ci.style.cssText = 'margin-right: 8px; color: #777; width: 18px; text-align: center; flex-shrink: 0;'; iconHtml = ci.outerHTML; } if (!nodeDef.title) { const txt = tb.textContent.replace(/<[^>]*>/g, '').trim(); if (txt) title = txt; } } } catch (e) { console.warn(`Err parsing sidebar HTML for ${nodeDef.name}:`, e); } div.innerHTML = `${iconHtml}<span style="flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(title)}</span>`; div.title = `Drag to add: ${title} (Type: ${nodeDef.name})`; if (!baseNodeDefinitions.hasOwnProperty(nodeDef.name)) { const del = document.createElement('button'); del.innerHTML = '<i class="fas fa-trash-alt" aria-hidden="true"></i>'; del.className = 'delete-node-type-btn'; del.title = `Delete node type: ${nodeDef.name}`; del.setAttribute('aria-label', `Delete node type ${nodeDef.name}`); del.onclick = (ev) => { ev.stopPropagation(); promptDeleteNodeType(nodeDef.name); }; div.appendChild(del); } div.addEventListener('dragstart', drag); div.addEventListener('touchstart', drag, { passive: false }); div.addEventListener('touchmove', positionMobile, { passive: false }); div.addEventListener('touchend', drop); nodesListContainer.appendChild(div); }
function loadCustomNodesToSidebar() { if (!nodesListContainer) return; try { const stored = getStoredCustomNodeTypes(); customNodeTypes = { ...baseNodeDefinitions, ...stored }; console.log("Node types loaded:", Object.keys(customNodeTypes).length); nodesListContainer.innerHTML = ''; if (nodeDefinitionModal) { const createBtnContainer = document.createElement('div'); createBtnContainer.className = 'create-node-button-wrapper'; const btn = document.createElement('button'); btn.className = 'create-node-button'; btn.setAttribute('role', 'button'); btn.innerHTML = '<i class="fas fa-plus-circle"></i><span>  Create Node Type</span>'; btn.title = 'Define a new custom node type'; btn.onclick = openNodeDefinitionModal; createBtnContainer.appendChild(btn); nodesListContainer.appendChild(createBtnContainer); } const defs = Object.values(customNodeTypes).sort((a, b) => (a.title || a.name).localeCompare(b.title || b.name)); defs.forEach(addDraggableItemToSidebar); filterNodes(); } catch (e) { console.error("Fatal sidebar load error:", e); showToast('error', 'Sidebar Error', 'Error loading node list.'); } }
function openNodeDefinitionModal() { if (!nodeDefinitionModal || !modalBackdrop) { showToast('error','Error','Modal dialog unavailable.'); return; } document.getElementById('newNodeTypeName').value = ''; document.getElementById('newNodeTypeTitle').value = ''; document.getElementById('newNodeInputs').value = '1'; document.getElementById('newNodeOutputs').value = '1'; document.getElementById('newNodeCssClass').value = ''; document.getElementById('newNodeHtmlContent').value = `<div>\n  <div class="title-box"><i class="fas fa-cogs"></i> My Node</div>\n  <div class="box">\n    <label>Data Field:</label>\n    <input type="text" df-mydata placeholder="Enter value...">\n  </div>\n</div>`; document.getElementById('newNodeInitialData').value = `{ "mydata": "" }`; nodeDefinitionModal.style.display = 'block'; modalBackdrop.style.display = 'block'; document.getElementById('newNodeTypeName').focus(); }
function closeNodeDefinitionModal() { if (!nodeDefinitionModal || !modalBackdrop) return; nodeDefinitionModal.style.display = 'none'; modalBackdrop.style.display = 'none'; }
function saveNewNodeType() { const nameIn=document.getElementById('newNodeTypeName'), titleIn=document.getElementById('newNodeTypeTitle'), inputsIn=document.getElementById('newNodeInputs'), outputsIn=document.getElementById('newNodeOutputs'), cssIn=document.getElementById('newNodeCssClass'), htmlIn=document.getElementById('newNodeHtmlContent'), dataIn=document.getElementById('newNodeInitialData'); if(!nameIn||!titleIn||!inputsIn||!outputsIn||!cssIn||!htmlIn||!dataIn) { showToast('error','Internal Error','Modal fields missing.'); return; } const name=nameIn.value.trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_]/g,''); const title=titleIn.value.trim(); const inputs=parseInt(inputsIn.value,10); const outputs=parseInt(outputsIn.value,10); const cssClass=cssIn.value.trim()||`${name}-node`; const html=htmlIn.value; const dataStr=dataIn.value.trim(); if(!name) { showToast('error','Validation Error','Internal name required.'); nameIn.focus(); return; } if(customNodeTypes[name]) { showToast('error','Validation Error',`Type "${name}" exists.`); nameIn.focus(); return; } if(isNaN(inputs)||inputs<0||isNaN(outputs)||outputs<0) { showToast('error','Validation Error','Inputs/Outputs >= 0.'); return; } if(!html) { showToast('error','Validation Error','HTML empty.'); htmlIn.focus(); return; } let iData={}; if(dataStr) { try { iData=JSON.parse(dataStr); if(typeof iData!=='object'||iData===null||Array.isArray(iData)) throw new Error("Initial Data must be JSON object."); } catch(e) { showToast('error','JSON Error',`Initial Data: ${e.message}`); dataIn.focus(); return; } } else { try { const tmp=document.createElement('div'); tmp.innerHTML=html; tmp.querySelectorAll('[df-]').forEach(el=>{ for(const a of el.attributes) if(a.name.startsWith('df-')){ const k=a.name.substring(3); if(!iData.hasOwnProperty(k)) { if (el.tagName === 'INPUT' && el.type === 'checkbox') { iData[k] = el.checked; } else { iData[k] = el.value ?? el.textContent ?? ''; } } } }); } catch(e){console.warn("Could not infer data:", e);} } const def={name, title: title || name, inputs, outputs, html, data: iData, cssClass}; customNodeTypes[name]=def; saveCustomNodeTypes(customNodeTypes); addDraggableItemToSidebar(def); const item=nodesListContainer.querySelector(`[data-node="${name}"]`); item?.scrollIntoView({behavior:'smooth',block:'nearest'}); showToast('success','Type Saved',`Type "${title||name}" added.`); closeNodeDefinitionModal(); }
function promptDeleteNodeType(nodeTypeName) { if(!nodeTypeName) return; if(baseNodeDefinitions.hasOwnProperty(nodeTypeName)){ showToast('warning','Not Allowed',`Base type "${nodeTypeName}" cannot be deleted.`); return; } if(!customNodeTypes.hasOwnProperty(nodeTypeName) || !getStoredCustomNodeTypes().hasOwnProperty(nodeTypeName)){ showToast('error','Not Found',`Custom type "${nodeTypeName}" not found.`); return; } const title=customNodeTypes[nodeTypeName]?.title||nodeTypeName; Swal.fire({title:`Delete Type "${title}"?`, text:`Removes definition for "${nodeTypeName}". Existing nodes may fail. Cannot be undone.`, icon:'warning', showCancelButton:true, confirmButtonColor:'#d33', cancelButtonColor:'#3085d6', confirmButtonText:'Yes, delete type', cancelButtonText:'Cancel'}).then((res) => { if(res.isConfirmed){ try { delete customNodeTypes[nodeTypeName]; saveCustomNodeTypes(customNodeTypes); loadCustomNodesToSidebar(); showToast('success','Type Deleted',`Type "${title}" deleted.`); } catch(err){ console.error(`Error deleting type ${nodeTypeName}:`,err); showToast('error','Delete Error', 'Failed delete.'); } } }); }

// --- History (Undo/Redo) ---
function initializeHistory() { historyStack = []; historyIndex = -1; updateUIDisabledStates(); console.log("History initialized."); }
function saveHistoryState(force = false) { if (!editor || (editor.editor_mode === 'fixed' && !force)) return; try { const currentState = JSON.stringify(editor.export()); if (!force && historyIndex >= 0 && historyStack[historyIndex] === currentState) { return; } if (historyIndex < historyStack.length - 1) { historyStack = historyStack.slice(0, historyIndex + 1); } historyStack.push(currentState); if (historyStack.length > MAX_HISTORY_STATES) { historyStack.shift(); } historyIndex = historyStack.length - 1; updateUIDisabledStates(); } catch (e) { console.error("Error saving history state:", e); } }
function undo() { if (historyIndex <= 0 || editor.editor_mode === 'fixed') return; try { historyIndex--; const previousStateJson = historyStack[historyIndex]; if (!previousStateJson) { console.error("Undo error: History state not found at index", historyIndex); historyIndex++; return; } const previousState = JSON.parse(previousStateJson); const currentModule = editor.module; cleanupAllModuleIntervals(); editor.import(previousState); if (editor.module !== currentModule) { console.warn("Module changed during Undo."); } else { activateExistingAutoNodes(); updateUIDisabledStates(); if(currentlyEditingNodeId && !editor.getNodeFromId(currentlyEditingNodeId)) closeCodeEditorSidebar(false); else if (currentlyEditingNodeId) openCodeEditorSidebar(currentlyEditingNodeId); } } catch (e) { console.error("Error during Undo operation:", e); historyIndex++; updateUIDisabledStates(); showToast('error', 'Undo Error', 'Failed restore.'); } }
function redo() { if (historyIndex >= historyStack.length - 1 || editor.editor_mode === 'fixed') return; try { historyIndex++; const nextStateJson = historyStack[historyIndex]; if (!nextStateJson) { console.error("Redo error: History state not found at index", historyIndex); historyIndex--; return; } const nextState = JSON.parse(nextStateJson); const currentModule = editor.module; cleanupAllModuleIntervals(); editor.import(nextState); if (editor.module !== currentModule) { console.warn("Module changed during Redo."); } else { activateExistingAutoNodes(); updateUIDisabledStates(); if(currentlyEditingNodeId && !editor.getNodeFromId(currentlyEditingNodeId)) closeCodeEditorSidebar(false); else if (currentlyEditingNodeId) openCodeEditorSidebar(currentlyEditingNodeId); } } catch (e) { console.error("Error during Redo operation:", e); historyIndex--; updateUIDisabledStates(); showToast('error', 'Redo Error', 'Failed restore.'); } }

// --- Project Management ---
function triggerLoad() { if (fileInputElement) fileInputElement.click(); else showToast('error', 'Error', 'File input missing.'); }
if (fileInputElement) fileInputElement.addEventListener('change', loadProjectFromFile);
function loadProjectFromFile(event) { const file = event.target?.files?.[0]; if (!file) { if(event?.target) event.target.value = null; return; } const projectName = file.name.replace(/\.json$/i, ""); const reader = new FileReader(); reader.onload = (e) => { try { const projectData = JSON.parse(e.target.result); if (!projectData?.drawflow) throw new Error("Invalid file: 'drawflow' missing."); if (projectData.customNodeDefinitions && typeof projectData.customNodeDefinitions === 'object') { saveCustomNodeTypes(projectData.customNodeDefinitions); customNodeTypes = { ...baseNodeDefinitions, ...projectData.customNodeDefinitions }; console.log("Loaded custom defs from file."); } else { customNodeTypes = { ...baseNodeDefinitions, ...getStoredCustomNodeTypes() }; console.log("Using local custom defs."); } loadCustomNodesToSidebar(); cleanupAllModuleIntervals(); editor.import(projectData); currentProjectName = projectName; initializeHistory(); selectedNodeId = null; copiedNodeData = null; updateUIDisabledStates(); closeCodeEditorSidebar(false); document.title = `Xocoflow | ${projectName} - ${editor.module}`; saveHistoryState(true); activateExistingAutoNodes(); showToast('success', 'Loaded', `"${projectName}" loaded.`); } catch (err) { console.error("Error loading project:", err); showToast('error', 'Load Error', `Load failed: ${err.message}`); } finally { if (event?.target) event.target.value = null; } }; reader.onerror = (e) => { showToast('error', 'Read Error', 'Could not read file.'); if(event?.target) event.target.value = null; }; reader.readAsText(file); }
function saveProject(filename) { if (!editor) return; if (!filename || typeof filename !== 'string') filename = currentProjectName || 'xocoflow_project'; filename = filename.trim().replace(/\.json$/i,""); if (!filename) filename = 'xocoflow_project'; filename += '.json'; try { const drawflowData = editor.export(); if (!drawflowData?.drawflow) throw new Error("Export failed."); const customDefs = getStoredCustomNodeTypes(); const project = { appName: "Xocoflow", version: "1.11", savedAt: new Date().toISOString(), customNodeDefinitions: customDefs, drawflow: drawflowData.drawflow }; const json = JSON.stringify(project, null, 2); const blob = new Blob([json], { type: 'application/json;charset=utf-8' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); currentProjectName = filename.replace(/\.json$/i, ""); document.title = `Xocoflow | ${currentProjectName} - ${editor.module}`; showToast('success', 'Saved', `${filename}`); } catch (err) { console.error("Error saving:", err); showToast('error', 'Save Error', `Could not save: ${err.message}`); } }
async function promptSaveAs() { try { const { value: inputName } = await Swal.fire({ title: 'Save As...', input: 'text', inputLabel: 'Filename (no .json)', inputValue: currentProjectName || 'my_project', showCancelButton: true, confirmButtonText: 'Save', cancelButtonText: 'Cancel', inputValidator: (v) => (!v?.trim() ? 'Name empty!' : (/[<>:"/\\|?*[\]]/.test(v)?'Invalid chars.':null)) }); if (inputName) saveProject(inputName.trim()); } catch (e) { showToast('error', 'Dialog Error', 'Save As error.'); } }
function exportRawJson() { try { const raw = editor.export(); if (!raw?.drawflow) throw new Error("Export failed."); const json = JSON.stringify(raw, null, 2); Swal.fire({ title: 'Raw Drawflow JSON', width: '80%', html: `<p>Raw data only. Does not include custom node definitions.</p><textarea readonly style="width: 95%; height: 400px; white-space: pre; overflow-wrap: normal; overflow-x: auto; background-color:#f0f0f0; border:1px solid #ccc; font-family:monospace; font-size:12px; margin-top:10px;">${escapeHtml(json)}</textarea>`, confirmButtonText: 'Close' }); } catch (e) { showToast('error', 'Export Error', `Export failed: ${e.message}`); } }
function clearCurrentModule() { if (!editor) return; const mod = editor.module; const nodesData = editor.export()?.drawflow?.[mod]?.data ?? {}; const count = Object.keys(nodesData).length; if (count === 0) { showToast('info', 'Empty', `Module "${escapeHtml(mod)}" empty.`); return; } try { Swal.fire({ title: `Clear Module "${escapeHtml(mod)}"?`, text: `Delete all ${count} nodes/connections? Cannot be undone.`, icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6', confirmButtonText: 'Yes, clear', cancelButtonText: 'Cancel' }).then((res) => { if (res.isConfirmed) { cleanupAllModuleIntervals(); editor.clearModuleSelected(); selectedNodeId = null; copiedNodeData = null; updateUIDisabledStates(); closeCodeEditorSidebar(false); if (mod === 'Home') { addWelcomeNode(mod); } saveHistoryState(true); showToast('info', 'Cleared', `"${escapeHtml(mod)}" cleared.`); } }); } catch (e) { showToast('error', 'Clear Error', 'Error clearing.'); } }

// --- Node Actions ---
function duplicateSelectedNode() { if (!selectedNodeId || editor.editor_mode === 'fixed') return; try { const oNode = editor.getNodeFromId(selectedNodeId); if (!oNode) throw new Error("Node not found."); const nodeDef = customNodeTypes[oNode.name]; if (!nodeDef) { showToast('error', 'Duplicate Error', `Type "${oNode.name}" unknown.`); return; } if (!nodeDef.html) throw new Error(`HTML missing for "${oNode.name}".`); const cData = JSON.parse(JSON.stringify(oNode.data || {})); const ins = Object.keys(oNode.inputs || {}).length, outs = Object.keys(oNode.outputs || {}).length; const x = oNode.pos_x + 40, y = oNode.pos_y + 40; const newId = editor.addNode(oNode.name, ins, outs, x, y, oNode.class, cData, nodeDef.html); saveHistoryState(); activateNodeIfNeeded(newId); } catch (err) { showToast('error', 'Duplicate Error', `Error: ${err.message}`); console.error("Duplicate error:", err); } }
function copySelectedNode() { if (!selectedNodeId) return; try { const node = editor.getNodeFromId(selectedNodeId); if (!node) throw new Error("Node not found."); const nodeDef = customNodeTypes[node.name]; if (!nodeDef) throw new Error(`Type "${node.name}" unknown.`); if (!nodeDef.html) throw new Error(`HTML missing for "${node.name}".`); copiedNodeData = { name: node.name, data: JSON.parse(JSON.stringify(node.data || {})), html: nodeDef.html, class: node.class, inputs: Object.keys(node.inputs || {}).length, outputs: Object.keys(node.outputs || {}).length, title: nodeDef.title || node.name }; updateUIDisabledStates(); showToast('success', 'Copied', `Copied: ${copiedNodeData.title}`); } catch (err) { console.error("Copy error:", err); copiedNodeData = null; updateUIDisabledStates(); showToast('error', 'Copy Error', `Error: ${err.message}`); } }
function pasteNode() { if (!copiedNodeData || editor.editor_mode === 'fixed') return; if (!customNodeTypes[copiedNodeData.name]) { showToast('error', 'Paste Error', `Type "${copiedNodeData.name}" unknown.`); copiedNodeData = null; updateUIDisabledStates(); return; } try { const rect = editor.container.getBoundingClientRect(), zoom = editor.zoom || 1; const viewCenterX = (rect.width / 2 - editor.canvas_x) / zoom; const viewCenterY = (rect.height / 2 - editor.canvas_y) / zoom; let w = 220, h = 80; try { const tempDiv = document.createElement('div'); tempDiv.style.position = 'absolute'; tempDiv.style.visibility = 'hidden'; tempDiv.innerHTML = copiedNodeData.html; document.body.appendChild(tempDiv); w = tempDiv.offsetWidth; h = tempDiv.offsetHeight; document.body.removeChild(tempDiv); } catch { /* Use defaults */ } const ox = Math.random() * 40 - 20, oy = Math.random() * 40 - 20; const x = viewCenterX - (w / 2) + ox, y = viewCenterY - (h / 2) + oy; const cData = JSON.parse(JSON.stringify(copiedNodeData.data)); const newId = editor.addNode(copiedNodeData.name, copiedNodeData.inputs, copiedNodeData.outputs, x, y, copiedNodeData.class, cData, copiedNodeData.html); saveHistoryState(); activateNodeIfNeeded(newId); } catch (err) { showToast('error', 'Paste Error', `Error: ${err.message}`); console.error("Paste error:", err); } }
function deleteSelectedNode() { if (!selectedNodeId || editor.editor_mode === 'fixed') return; try { editor.removeNodeId(`node-${selectedNodeId}`); } catch (err) { showToast('error', 'Delete Error', `Error: ${err.message}`); console.error("Delete error:", err); } }

// --- Module/Tab Management ---
function renderModuleTabs() { /* Sin cambios */
    if (!moduleListElement) return;
    try {
        moduleListElement.innerHTML = '';
        const modulesData = editor.export().drawflow || {};
        const currentModule = editor.module;
        let moduleNames = Object.keys(modulesData);
        if (moduleNames.length === 0) {
             if (!modulesData['Home']) { editor.addModule('Home'); moduleNames = ['Home']; }
             else { moduleNames = ['Home']; }
        }
        moduleNames.sort((a, b) => (a === 'Home' ? -1 : b === 'Home' ? 1 : a.localeCompare(b)));

        moduleNames.forEach(moduleName => {
            const li = document.createElement('li');
            li.textContent = moduleName;
            li.dataset.moduleName = moduleName;
            li.title = `Cambiar a: ${moduleName}`;
            // ----------- AQUI SE CAMBIA -----------
            li.onclick = () => {
                editor.changeModule(moduleName);
                // Si quieres que las pestañas se vuelvan a renderizar inmediatamente:
                renderModuleTabs();
            };
            // ---------------------------------------
        
            if (moduleName === currentModule) li.classList.add('selected');
        
            if (moduleName !== 'Home' && moduleNames.length > 1) {
                const closeBtn = document.createElement('span');
                closeBtn.innerHTML = '×';
                closeBtn.title = `Eliminar ${moduleName}`;
                closeBtn.className = 'close-tab-btn';
                closeBtn.style.cssText = `
                    margin-left: 8px;
                    cursor: pointer;
                    color: #aaa;
                    font-weight: bold;
                    padding: 0 4px;
                    border-radius: 3px;
                    font-size: 14px;
                    line-height: 1;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    height: 16px;
                    width: 16px;
                    vertical-align: middle;
                    transition: all 0.2s;
                `;
                closeBtn.onmouseover = () => {
                    closeBtn.style.color = '#fff';
                    closeBtn.style.backgroundColor = '#ffb3b3';
                };
                closeBtn.onmouseout = () => {
                    closeBtn.style.color = '#aaa';
                    closeBtn.style.backgroundColor = 'transparent';
                };
                closeBtn.onclick = (ev) => {
                    ev.stopPropagation();
                    removeModuleTab(moduleName);
                };
                li.appendChild(closeBtn);
            }
        
            moduleListElement.appendChild(li);
        });
        

        const addBtn = document.createElement('li'); addBtn.innerHTML = '<i class="fas fa-plus"></i>';
        addBtn.title = "Añadir módulo"; addBtn.className = 'add-tab-btn';
        addBtn.style.cssText = `cursor: pointer; border-right: none; padding: 0 10px; background-color: transparent; margin-left: 5px; opacity: 0.7; transition: opacity 0.2s;`;
        addBtn.onmouseover = () => { addBtn.style.opacity = '1'; }; addBtn.onmouseout = () => { addBtn.style.opacity = '0.7'; };
        addBtn.onclick = promptAddModule;
        moduleListElement.appendChild(addBtn);
    } catch (e) { console.error("Error en renderModuleTabs:", e); }
}

async function promptAddModule() { /* Sin cambios */
    try {
        const { value: moduleNameInput } = await Swal.fire({
             title: 'Nuevo Módulo', input: 'text', inputLabel: 'Nombre', inputValue: '',
             showCancelButton: true, confirmButtonText: 'Crear', cancelButtonText: 'Cancelar',
             inputValidator: (v) => {
                const t = v?.trim(); if (!t) return 'Nombre vacío.';
                const existing = Object.keys(editor.export().drawflow || {});
                if (existing.some(m => m.toLowerCase() === t.toLowerCase())) return `"${t}" ya existe.`;
                if (/[<>:"/\\|?*]/.test(t)) return 'Caracteres inválidos.';
                return null;
             }
        });
        const moduleName = moduleNameInput?.trim();
        if (moduleName) {
            console.log(`Añadiendo módulo: ${moduleName}`);
            editor.addModule(moduleName);
            editor.changeModule(moduleName); // Dispara 'moduleChanged'
            renderModuleTabs(); // 'moduleChanged' debería llamarlo
            addWelcomeNode(moduleName); // Añadir nodo bienvenida al nuevo módulo
        } else { console.log("Creación cancelada."); }
    } catch (e) { console.error("Error en promptAddModule:", e); }
}
function removeModuleTab(moduleName) { /* Adaptado para limpiar intervalos */
    if (moduleName === 'Home') { Swal.fire('No permitido', 'No puedes eliminar "Home".', 'warning'); return; }
    const moduleCount = Object.keys(editor.export().drawflow || {}).length;
    if (moduleCount <= 1) { Swal.fire('No permitido', 'No puedes eliminar el último módulo.', 'warning'); return; }

    try {
        Swal.fire({
            title: `¿Eliminar Módulo "${moduleName}"?`, text: "Acción permanente.", icon: 'warning',
            showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6',
            confirmButtonText: 'Sí, eliminar', cancelButtonText: 'Cancelar'
         }).then((result) => {
            if (result.isConfirmed) {
                console.log(`Eliminando módulo: ${moduleName}`);
                const currentActiveModule = editor.module;

                // Limpiar intervalos ANTES de cambiar de módulo si es el activo
                if (currentActiveModule === moduleName) {
                     cleanupAllModuleIntervals();
                }

                try {
                     editor.removeModule(moduleName);
                     console.log(`Módulo "${moduleName}" eliminado.`);
                     if (currentActiveModule === moduleName) {
                         console.log("Cambiando a 'Home' tras eliminar activo.");
                         editor.changeModule('Home'); // Dispara 'moduleChanged'
                     } else {
                         console.log("Módulo inactivo eliminado. Renderizando pestañas.");
                         renderModuleTabs(); // Re-renderizar manualmente
                         saveHistoryState(true); // Guardar estado tras eliminar inactivo
                     }
                 } catch (removeError) { console.error(`Error eliminando módulo:`, removeError); Swal.fire('Error', `No se pudo eliminar: ${removeError.message}`, 'error'); }
            } else { console.log("Eliminación cancelada."); }
        });
    } catch (e) { console.error("Error confirmación eliminar:", e); }
}


// --- UI Helpers ---
function changeMode(option) { try { if (!lockButton || !unlockButton || !editor) return; const isLocking = option === 'lock'; editor.editor_mode = isLocking ? 'fixed' : 'edit'; lockButton.style.display = isLocking ? 'none' : ''; unlockButton.style.display = isLocking ? '' : 'none'; const swEl = lockButton.parentElement; if(swEl) swEl.setAttribute('aria-checked', String(isLocking)); drawflowElement?.classList.toggle('drawflow-locked', isLocking); drawflowElement?.classList.toggle('drawflow-unlocked', !isLocking); showToast('info', `Editor ${isLocking ? 'Locked' : 'Unlocked'}`, '', 1500); updateUIDisabledStates(); if (isLocking) closeCodeEditorSidebar(false); } catch (e) { console.error("Error changeMode:", e); } }
function updateUIDisabledStates() { try { const isLocked = editor?.editor_mode === 'fixed'; const nodeSel = selectedNodeId !== null; const canUndo = historyIndex > 0; const canRedo = historyIndex < historyStack.length - 1; const canPaste = copiedNodeData !== null; const hasNodes = editor ? Object.keys(editor.export()?.drawflow?.[editor.module]?.data ?? {}).length > 0 : false; const setCtrl = (btn, vis, dis = false) => { if (btn) { btn.classList.toggle('hidden', !vis); btn.disabled = !vis || dis; } }; setCtrl(undoButton, !isLocked && canUndo, isLocked || !canUndo); setCtrl(redoButton, !isLocked && canRedo, isLocked || !canRedo); setCtrl(copyButton, !isLocked && nodeSel, isLocked || !nodeSel); setCtrl(duplicateButton, !isLocked && nodeSel, isLocked || !nodeSel); setCtrl(pasteButton, !isLocked && canPaste, isLocked || !canPaste); if (recalculateButton) setCtrl(recalculateButton, !isLocked && hasNodes, isLocked || !hasNodes); if (lockButton && unlockButton) { lockButton.disabled = isLocked; unlockButton.disabled = !isLocked; lockButton.style.display = isLocked ? 'none' : ''; unlockButton.style.display = isLocked ? '' : 'none'; const sw = lockButton.parentElement; if(sw) sw.setAttribute('aria-checked', String(isLocked)); } if (nodesListContainer) { nodesListContainer.style.opacity = isLocked ? '0.6' : '1'; nodesListContainer.style.pointerEvents = isLocked ? 'none' : ''; } const actionButtons = document.querySelectorAll('.menu .btn-save, .menu .btn-save-as, .menu .btn-export, .menu .btn-clear'); actionButtons.forEach(btn => { if(btn) btn.disabled = isLocked; }); const createBtn = nodesListContainer?.querySelector('.create-node-button'); if (createBtn) createBtn.disabled = isLocked; nodesListContainer?.querySelectorAll('.drag-drawflow').forEach(el => el.draggable = !isLocked); updateNodePositionStatus(selectedNodeId); } catch(e){ console.error("Error updating UI states:", e); } }

// --- Drag and Drop ---
var mobile_item_selec = ''; var mobile_last_move = null; function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { try { const el = ev.target.closest(".drag-drawflow"); if (!el) { ev.preventDefault(); return;} const nt = el.dataset.node; if (!nt) { ev.preventDefault(); return;} if (editor && editor.editor_mode === 'fixed') { showToast('warning', 'Editor Locked', 'Cannot drag.'); ev.preventDefault(); return; } if (ev.type === "touchstart") { mobile_item_selec = nt; mobile_last_move = ev; el.style.opacity = '0.5';} else { ev.dataTransfer.setData("node", nt); ev.dataTransfer.effectAllowed = 'copy';} } catch(e){console.error("Drag error:",e);} } function positionMobile(ev) { mobile_last_move = ev; } function drop(ev) { let nodeName='',clientX=0,clientY=0,isTouch=false; try { if (mobile_item_selec) { const orig = nodesListContainer?.querySelector(`[data-node="${mobile_item_selec}"]`); if (orig) orig.style.opacity = '1'; } if (ev.type === "touchend") { isTouch=true; if(!mobile_last_move||!mobile_item_selec) return; clientX=mobile_last_move.changedTouches[0].clientX; clientY=mobile_last_move.changedTouches[0].clientY; nodeName=mobile_item_selec; mobile_item_selec=''; mobile_last_move=null; } else { ev.preventDefault(); nodeName=ev.dataTransfer.getData("node"); clientX=ev.clientX; clientY=ev.clientY; } if (!editor || editor.editor_mode === 'fixed') { console.warn("Drop ignored: locked."); return; } const targetEl = isTouch ? document.elementFromPoint(clientX, clientY) : ev.target; if (nodeName && targetEl?.closest(`#${DRAWFLOW_CONTAINER_ID}`)) { addNodeToDrawFlow(nodeName, clientX, clientY); } else { console.log("Drop outside canvas."); } } catch(e){console.error("Drop error:",e); showToast('error', 'Drop Error', 'Place failed.'); if(isTouch){ mobile_item_selec=''; mobile_last_move=null;}} }
function addNodeToDrawFlow(name, pos_x, pos_y) { if(!editor || editor.editor_mode==='fixed'){ showToast('warning', 'Locked', 'Cannot add.'); return false; } try { const nodeDef=customNodeTypes[name]; if(!nodeDef) throw new Error(`Type "${name}" unknown.`); if(!nodeDef.html) throw new Error(`HTML missing for "${name}".`); const rect=editor.container.getBoundingClientRect(), zoom=editor.zoom||1; const canvasX=(pos_x-rect.left-editor.canvas_x)/zoom, canvasY=(pos_y-rect.top-editor.canvas_y)/zoom; let w = parseInt(nodeDef.data?.nodewidth, 10) || (nodeDef.name === 'local_image' ? 240 : 220); let h = parseInt(nodeDef.data?.nodeheight, 10) || (nodeDef.name === 'local_image' ? 'auto' : 80); if (h === 'auto' || isNaN(h)) h = 100; const adjX=canvasX-(w/2), adjY=canvasY-(h/2); const data=JSON.parse(JSON.stringify(nodeDef.data||{})); const nodeId=editor.addNode(name, nodeDef.inputs, nodeDef.outputs, adjX, adjY, nodeDef.cssClass||'', data, nodeDef.html); saveHistoryState(); activateNodeIfNeeded(nodeId); return true; } catch(e){console.error(`Error adding node "${name}":`,e); showToast('error', 'Add Error', `Error: ${e.message}`); return false;} }

// --- Recalculate All ---
function recalculateAllNodesInCurrentModule() { if (!editor || editor.editor_mode === 'fixed') { showToast('warning', 'Locked', 'Cannot recalculate.'); return; } const mod = editor.module; const nodes = editor.export()?.drawflow?.[mod]?.data ?? {}; const ids = Object.keys(nodes); if (ids.length === 0) { showToast('info', 'Empty', `Module "${escapeHtml(mod)}" empty.`); return; } console.log(`%cRecalculating: ${mod}...`, 'color: orange; font-weight: bold;'); showToast('info', 'Recalculating...', `Module ${escapeHtml(mod)}.`, 2500); try { cleanupAllModuleIntervals(); ids.forEach(id => { const node = nodes[id]; if (node && (getConnections(id, 'input').length === 0 || ['url_input', 'cargarTexto', 'texto', 'static_code_snippet', 'timer_fetch', 'timer_download', 'loop', 'repeat'].includes(node.name)) ) { activateNodeIfNeeded(id); } }); ids.forEach(id => { if (nodes[id]?.name === 'concatenar') { updateConcatenateNode(id); } }); showToast('success', 'Recalculated', `${escapeHtml(mod)} updated.`); } catch (err) { console.error("Recalculation error:", err); showToast('error', 'Error', 'Recalculation failed.'); } }

// --- CodeMirror Sidebar ---
function initializeCodeMirror() { if (codeMirrorEditor || !codeMirrorElement || typeof CodeMirror === 'undefined') return; try { codeMirrorContainer = codeMirrorElement; codeMirrorEditor = CodeMirror(codeMirrorContainer, { lineNumbers: true, mode: "javascript", theme: "material-darker", matchBrackets: true, autoCloseBrackets: true, indentUnit: 2, tabSize: 2, lineWrapping: true, gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"] }); if (codeEditorSaveButton) codeEditorSaveButton.addEventListener('click', saveAndCloseCodeEditor); if (codeEditorCloseButton) codeEditorCloseButton.addEventListener('click', () => closeCodeEditorSidebar(true)); console.log("CodeMirror initialized."); } catch (e) { console.error("Error initializing CodeMirror:", e); codeMirrorEditor = null; showToast('error', 'CodeMirror Error', 'Failed init.'); } }
function openCodeEditorSidebar(nodeId) { if (!codeEditorSidebar || !nodeId) return; if (editor && editor.editor_mode === 'fixed') { showToast('warning', 'Locked', 'Cannot edit code.'); return; } if (!codeMirrorEditor) initializeCodeMirror(); if (!codeMirrorEditor) { showToast('error', 'Editor Error', 'Code editor unavailable.'); return; } const node = editor.getNodeFromId(nodeId); const types = ['javascript_code', 'static_code_snippet', 'texto']; if (!node || !types.includes(node.name)) { if (codeEditorSidebar.classList.contains('visible')) closeCodeEditorSidebar(true); return; } if (currentlyEditingNodeId && currentlyEditingNodeId !== nodeId && codeEditorSidebar.classList.contains('visible')) { closeCodeEditorSidebar(true); } let dfKey = '', iconClass = '', editorTitle = '', editorMode = 'text/plain'; switch (node.name) { case 'javascript_code': dfKey='jscode'; iconClass='fab fa-js-square'; editorTitle='Edit JS Code'; editorMode='javascript'; break; case 'static_code_snippet': dfKey='codecontent'; iconClass='fas fa-code'; editorTitle='Edit Static Code'; editorMode='htmlmixed'; break; case 'texto': dfKey='content'; iconClass='fas fa-paragraph'; editorTitle='Edit Text / HTML'; editorMode='htmlmixed'; break; } const currentCode = node.data[dfKey] || ''; const currentCmMode = codeMirrorEditor.getOption('mode'); if (currentCmMode !== editorMode) { codeMirrorEditor.setOption('mode', editorMode); } if (codeMirrorEditor.getValue() !== currentCode) { codeMirrorEditor.setValue(currentCode); codeMirrorEditor.clearHistory(); } if (codeEditorTitleSpan) codeEditorTitleSpan.textContent = editorTitle; const titleIcon = codeEditorSidebar.querySelector('.sidebar-header h3 i'); if (titleIcon) titleIcon.className = iconClass + " fa-fw"; if (editingNodeIdSpan) editingNodeIdSpan.textContent = nodeId; currentlyEditingNodeId = nodeId; if (!codeEditorSidebar.classList.contains('visible')) { codeEditorSidebar.classList.add('visible'); codeEditorSidebar.setAttribute('aria-hidden', 'false'); setTimeout(() => { if (codeMirrorEditor) { codeMirrorEditor.refresh(); codeMirrorEditor.focus(); codeMirrorEditor.setCursor({ line: 0, ch: 0 }); } }, 100); } else { if (codeMirrorEditor) codeMirrorEditor.focus(); } }
function closeCodeEditorSidebar(save = false) { if (!codeEditorSidebar || !codeEditorSidebar.classList.contains('visible')) { if(currentlyEditingNodeId) currentlyEditingNodeId = null; return; } const closingId = currentlyEditingNodeId; if (save && closingId && codeMirrorEditor) { const currentCode = codeMirrorEditor.getValue(); try { const node = editor.getNodeFromId(closingId); if (node) { const name = node.name; let dfKey = ''; switch (name) { case 'javascript_code': dfKey = 'jscode'; break; case 'static_code_snippet': dfKey = 'codecontent'; break; case 'texto': dfKey = 'content'; break; } if (dfKey && node.data[dfKey] !== currentCode) { editor.updateNodeDataFromId(closingId, { [dfKey]: currentCode }); const nodeElement = document.getElementById(`node-${closingId}`); const textarea = nodeElement?.querySelector(`textarea[df-${dfKey}]`); if (textarea) { textarea.value = currentCode; } if (name === 'texto' || name === 'static_code_snippet') { propagateData(closingId, name, dfKey, currentCode); } saveHistoryState(); } } else { console.warn(`Node ${closingId} not found when saving.`); } } catch (saveError) { console.error(`Error saving code for ${closingId}:`, saveError); showToast('error', 'Save Error', 'Could not save.'); } } codeEditorSidebar.classList.remove('visible'); codeEditorSidebar.setAttribute('aria-hidden', 'true'); currentlyEditingNodeId = null; if (editingNodeIdSpan) editingNodeIdSpan.textContent = 'N/A'; }
function saveAndCloseCodeEditor() { closeCodeEditorSidebar(true); }

// --- Status Bar ---
function updateZoomStatus(level) { if (zoomLevelSpan) zoomLevelSpan.textContent = `${Math.round(level * 100)}%`; }
function updateNodePositionStatus(nodeId) { if (nodePositionSpan) { if (nodeId) { try { const n = editor.getNodeFromId(nodeId); if (n) nodePositionSpan.textContent = `X:${Math.round(n.pos_x)},Y:${Math.round(n.pos_y)}`; else nodePositionSpan.textContent = `X:-,Y:-`; } catch { nodePositionSpan.textContent = `X:?,Y:?`; } } else nodePositionSpan.textContent = `X:-,Y:-`; } }

// --- Drawflow Event Listeners ---
try {
    editor.on('nodeRemoved', (id) => { console.log(`Event: Node Removed ${id}`); cleanupNodeIntervals(id); if (selectedNodeId === id) { selectedNodeId = null; updateNodePositionStatus(null); } if (currentlyEditingNodeId === id) closeCodeEditorSidebar(false); updateUIDisabledStates(); saveHistoryState(); });
    editor.on('nodeSelected', (id) => { console.log(`Event: Node Selected ${id}`); selectedNodeId = id; updateUIDisabledStates(); updateNodePositionStatus(id); const n = editor.getNodeFromId(id); const editTypes = ['javascript_code', 'static_code_snippet', 'texto']; if (n && editTypes.includes(n.name)) { if (!codeMirrorEditor) initializeCodeMirror(); if (codeMirrorEditor && editor.editor_mode !== 'fixed') { openCodeEditorSidebar(id); } } else { closeCodeEditorSidebar(true); } });
    editor.on('nodeUnselected', (deselectedExplicitly) => { console.log(`Event: Node Unselected (Explicit: ${deselectedExplicitly})`); if (currentlyEditingNodeId && selectedNodeId === currentlyEditingNodeId) { closeCodeEditorSidebar(true); } selectedNodeId = null; updateUIDisabledStates(); updateNodePositionStatus(null); });
    editor.on('nodeMoved', (id) => { saveHistoryState(); if(id === selectedNodeId) updateNodePositionStatus(id); try { const n = editor.getNodeFromId(id); if(n){ const outs=getConnections(id,'output'); outs.forEach(c=>{ try{if(editor.getNodeFromId(c.node)?.name==='concatenar')updateConcatenateNode(c.node);}catch(e){} }); const ins=getConnections(id,'input'); ins.forEach(c=>{ try{if(editor.getNodeFromId(c.output_id)?.name==='concatenar')updateConcatenateNode(c.output_id);}catch(e){} }); if(n.name==='concatenar'){updateConcatenateNode(id);} } } catch(e){ console.error("Error nodeMoved connections:", e); } });
    editor.on('connectionCreated', (c) => { console.log('Event: Conn Created', c); setTimeout(() => { try { const sId=c.output_id, tId=c.input_id; const sN=editor.getNodeFromId(sId), tN=editor.getNodeFromId(tId); if(!sN||!tN) throw new Error("Src/Tgt node missing."); const tName=tN.name, tPort=c.input_class; const ignore=['texto','static_code_snippet', 'local_image']; if(ignore.includes(tName)){saveHistoryState();return;} let data; const sD=sN.data; if(sD){ const keys=['result','content','codecontent','outputhtml','filecontent','display','url','jscode']; for(const k of keys){if(sD.hasOwnProperty(k)){data=sD[k];break;}} if(data===undefined && Object.keys(sD).length>0){const fk=Object.keys(sD).filter(k => !['lastInput','selector_received'].includes(k))[0]; if(fk) data=sD[fk]; } } if(EXECUTE_NODE_SYSTEM_TYPES.includes(tName)){if(tName==='extract_value'){if(tPort==='input_1')executeNode(tId,data);else if(tPort==='input_2'){const s=String(data??'');editor.updateNodeDataFromId(tId,{selector_received:s});const el=document.getElementById(`node-${tId}`);const i=el?.querySelector('input[df-selector_received]');if(i)i.value=s; const currentText = readField(tId, 'result'); if(currentText !== '(Esperando texto)' && currentText !== '(Esperando)') { setTimeout(() => executeNode(tId, currentText), 0); } }}else executeNode(tId,data);}else if(tName==='javascript_code')editor.updateNodeDataFromId(tId,{lastInput:data});else if(tName==='concatenar')updateConcatenateNode(tId);else if(tName==='mostrarPasar'){if(tPort==='input_1'){const v=String(data??'');editor.updateNodeDataFromId(tId,{result:v});const el=document.getElementById(`node-${tId}`);const ta=el?.querySelector('textarea[df-result]');if(ta)ta.value=v;propagateData(tId,tName,'result',data);}}else if(tName==='guardarTexto'){if(tPort==='input_1'){const v=String(data??'');editor.updateNodeDataFromId(tId,{savecontent:v});const el=document.getElementById(`node-${tId}`);const ta=el?.querySelector('textarea[df-savecontent]');if(ta)ta.value=v;}} saveHistoryState();}catch(err){console.error("Error connectionCreated:",err);saveHistoryState();}},0);});
    editor.on('connectionRemoved', (c) => { console.log('Event: Conn Removed', c); try { const tId = c.input_id, tN = editor.getNodeFromId(tId); if (tN?.name === 'concatenar') { setTimeout(() => updateConcatenateNode(tId), 0); } } catch (e) { console.error("Error connectionRemoved:", e); } saveHistoryState(); });
    editor.on('moduleChanged', (name) => { console.log(`%cEVENT: Module Changed -> ${name}`, 'color: blue; font-weight: bold;'); renderModuleTabs(); cleanupAllModuleIntervals(); initializeHistory(); selectedNodeId = null; copiedNodeData = null; currentlyEditingNodeId = null; updateUIDisabledStates(); updateZoomStatus(editor.zoom); updateNodePositionStatus(null); document.title = `Xocoflow | ${currentProjectName} - ${name}`; closeCodeEditorSidebar(false); setTimeout(() => { saveHistoryState(true); activateExistingAutoNodes(); console.log(` -> Module ${name} loaded.`); }, 50); });
    editor.on('zoom', (level) => { updateZoomStatus(level); });
    editor.on('translate', (pos) => { /* Log */ });
    editor.on('contextmenu', (e) => { e.preventDefault(); });
    editor.on('click', (e) => { if (codeEditorSidebar?.classList.contains('visible') && !e.target.closest('#code-editor-sidebar')) { const nodeEl = currentlyEditingNodeId ? document.getElementById(`node-${currentlyEditingNodeId}`) : null; if (!nodeEl || !nodeEl.contains(e.target)) { closeCodeEditorSidebar(true); } } if (!e.target.closest('.drawflow-node,.controls-container,.menu,.swal2-container,#code-editor-sidebar,.CodeMirror')) { if (selectedNodeId) { editor.deselectNode(selectedNodeId); } } });
    // Node Created Listener (Refined v1.11 - Includes connection update on size change)
    editor.on('nodeCreated', function(id) {
        try {
            const node = editor.getNodeFromId(id);
            if (!node) return;
            const nodeElement = document.getElementById(`node-${id}`);
            if (!nodeElement) return;

            let sizeChanged = false; // Flag for connection update

            // --- local_image: Apply NODE size and IMAGE visuals ---
            if (node.name === 'local_image') {
                const initialWidth = nodeElement.style.width;
                const initialHeight = nodeElement.style.height;
                const targetWidth = node.data?.nodewidth || '240px';
                const targetHeight = node.data?.nodeheight || 'auto';

                nodeElement.style.width = targetWidth;
                nodeElement.style.height = targetHeight;

                if (targetWidth !== initialWidth || targetHeight !== initialHeight) {
                    sizeChanged = true;
                }

                const imgTag = nodeElement.querySelector('img[df-imagesrc]');
                const placeholderText = nodeElement.querySelector('.placeholder-text');
                const filenameSpan = nodeElement.querySelector('span[df-filename]');
                if (node.data?.imagesrc && imgTag && placeholderText) {
                    imgTag.src = node.data.imagesrc;
                    imgTag.style.display = 'block';
                    imgTag.style.width = node.data.imagewidth || '100%';
                    imgTag.style.height = node.data.imageheight || 'auto';
                    placeholderText.style.display = 'none';
                    if (filenameSpan && node.data.filename) { filenameSpan.textContent = node.data.filename; filenameSpan.title = node.data.filename;}
                } else if (imgTag && placeholderText) {
                    imgTag.style.display = 'none';
                    placeholderText.style.display = 'block';
                    if (filenameSpan) filenameSpan.textContent = '';
                }
            }
            // --- nota: Apply background color and update char count ---
            else if (node.name === 'nota') {
                 if (node.data?.notecolor) { nodeElement.style.backgroundColor = node.data.notecolor; }
                 const textarea = nodeElement.querySelector('textarea[df-notecontent]');
                 const countSpan = nodeElement.querySelector('[df-charcount]');
                 if(textarea && countSpan) { countSpan.textContent = textarea.value?.length || 0; }
            }

            // Update connections AFTER applying styles if size might have changed
            if (sizeChanged) {
                 setTimeout(() => {
                     editor.updateConnectionNodes(`node-${id}`);
                     console.log(`Connections updated for node ${id} after creation/size apply.`);
                 }, 0);
            }

        } catch(e) { console.error(`Error in nodeCreated handler for ID ${id}:`, e); }
    });

} catch (e) { console.error("Error setting Drawflow listeners:", e); showToast('error', 'Critical Error', 'Failed setup listeners.'); }

// --- Keyboard Shortcuts ---
document.addEventListener('keydown', (event) => { try { const active = document.activeElement; const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable); const isModal = nodeDefinitionModal?.style.display !== 'none'; const isCM = codeMirrorEditor && codeMirrorEditor.hasFocus(); const isSidebar = codeEditorSidebar?.contains(active); if (event.key === 'Escape') { if (isModal) { closeNodeDefinitionModal(); event.preventDefault(); return; } if (isCM || (isSidebar && currentlyEditingNodeId)) { closeCodeEditorSidebar(true); event.preventDefault(); return; } if (selectedNodeId) { editor.deselectNode(selectedNodeId); event.preventDefault(); return; } } if (isInput && !isCM && !isSidebar && !(event.ctrlKey || event.metaKey) && !['Escape','Delete','Backspace','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(event.key) ) { return; } const ctrl = event.ctrlKey || event.metaKey; const isEditorFocused = !isInput && !isModal && !isCM && !isSidebar; if (ctrl) { switch (event.key.toLowerCase()) { case 'z': if (isEditorFocused || isCM || isSidebar) { event.preventDefault(); undo(); } break; case 'y': if (isEditorFocused || isCM || isSidebar) { event.preventDefault(); redo(); } break; case 'c': if(selectedNodeId && isEditorFocused){event.preventDefault(); copySelectedNode();} break; case 'v': if(isEditorFocused){event.preventDefault(); pasteNode();} break; case 'd': if(selectedNodeId && isEditorFocused){event.preventDefault(); duplicateSelectedNode();} break; case 's': if (isEditorFocused || isCM || isSidebar) { event.preventDefault(); if (event.shiftKey) promptSaveAs(); else saveProject(currentProjectName); } break; case 'o': if (isEditorFocused) { event.preventDefault(); triggerLoad(); } break; case 'r': if(recalculateButton && isEditorFocused){event.preventDefault(); recalculateAllNodesInCurrentModule();} break; } } else { switch (event.key) { case 'Delete': case 'Backspace': if (selectedNodeId && isEditorFocused) { event.preventDefault(); deleteSelectedNode(); } break; } } } catch (e) { console.error("Keyboard shortcut error:", e); } });

// --- Application Initialization ---
function initializeApp() { try { console.log("🚀 Initializing Xocoflow..."); showToast('info', 'Initializing...', '', 1500); editor.start(); console.log("Drawflow started."); const initialExport = editor.export(); const initialModules = initialExport?.drawflow; let homeExists = initialModules?.hasOwnProperty('Home'); if (!initialModules || Object.keys(initialModules).length === 0 || !homeExists) { if (!homeExists) editor.addModule('Home'); if (editor.module !== 'Home') editor.changeModule('Home'); } else if (!editor.module || !initialModules[editor.module]) { editor.changeModule('Home'); } console.log(`Initial active module: ${editor.module}`); loadCustomNodesToSidebar(); renderModuleTabs(); initializeHistory(); updateUIDisabledStates(); updateZoomStatus(editor.zoom); updateNodePositionStatus(null); document.title = `Xocoflow | ${currentProjectName} - ${editor.module}`; changeMode('edit'); const currentModuleData = editor.export()?.drawflow?.[editor.module]?.data ?? {}; if (Object.keys(currentModuleData).length === 0) { addWelcomeNode(editor.module); saveHistoryState(true); } else { saveHistoryState(true); activateExistingAutoNodes(); } if (recalculateButton) recalculateButton.addEventListener('click', recalculateAllNodesInCurrentModule); initializeCodeMirror(); console.log("%cXocoflow Ready.", "color: green; font-weight: bold;"); showToast('success', 'Ready', 'Editor initialized.', 1500); } catch (error) { console.error("❌ FATAL INITIALIZATION ERROR:", error); document.body.innerHTML = `<div style="padding: 20px; background-color: #ffcdd2; border: 2px solid red; color: #b71c1c; font-family: sans-serif; text-align: center;"><h1><i class="fas fa-bomb"></i> Critical Error</h1><p>Xocoflow failed to initialize. Check console (F12).</p><pre style="text-align: left; white-space: pre-wrap; word-wrap: break-word; background-color: #ffcdd2; border: 1px solid #e57373; padding: 10px; margin-top: 15px; max-height: 300px; overflow-y: auto;">${escapeHtml(error.stack || String(error))}</pre><p style="margin-top:15px;"><button onclick="location.reload()">Reload</button></p></div>`; throw error; } }
function addWelcomeNode(moduleName) { if (!editor || !moduleName || editor.editor_mode === 'fixed') return; try { const exported = editor.export(); const existingData = exported?.drawflow?.[moduleName]?.data ?? {}; if (Object.keys(existingData).length > 0) return; const htmlContent = `<div><div class="title-box" style="background-color:#4CAF50 !important; color:white !important; border-bottom: 1px solid #388E3C !important;"><i class="fas fa-rocket" style="color:white !important;"></i> Welcome to ${escapeHtml(moduleName)}!</div><div class="box" style="background-color: transparent; font-size: var(--font-size-small); line-height: 1.6; padding: 15px;"><p style="color: var(--text-dark); margin-bottom: 10px;"><strong style="color: var(--success-dark-color);">Quick Start:</strong></p><ul style="margin-top:5px;padding-left:20px; margin-bottom: 0; list-style: none;"><li><i class="fas fa-mouse-pointer fa-fw" style="margin-right: 8px; color:#007bff;"></i> Drag nodes from left.</li><li><i class="fas fa-link fa-fw" style="margin-right: 8px; color:#ff9800;"></i> Connect outputs <i class="fas fa-arrow-right fa-xs"></i> to inputs <i class="fas fa-arrow-left fa-xs"></i>.</li><li><i class="fas fa-edit fa-fw" style="margin-right: 8px; color:#9c27b0;"></i> Use "Edit Content/Code".</li><li><i class="fas fa-save fa-fw" style="margin-right: 8px; color:#4CAF50;"></i> Save often.</li><li><i class="fas fa-plus-circle fa-fw" style="margin-right: 8px; color:#1a73e8;"></i> Explore "Create Node Type".</li></ul></div></div>`; const nodeWidth = 280; const nodeHeight = 210; const rect = editor.container.getBoundingClientRect(); const zoom = editor.zoom || 1; const cx = (rect.width / 2 - editor.canvas_x) / zoom; const cy = (rect.height / 2 - editor.canvas_y) / zoom; const posX = cx - nodeWidth / 2; const posY = cy - nodeHeight / 2; const name = 'xocoflow_welcome_info'; if (!customNodeTypes[name]) { editor.registerNode(name, () => {}, {}, {}); customNodeTypes[name] = { name: name, inputs: 0, outputs: 0, html: htmlContent, data: {}, cssClass: 'welcome-node' }; } const id = editor.addNode(name, 0, 0, posX, posY, 'welcome-node', {}, htmlContent); console.log(`Welcome node ${id} added to module ${moduleName}.`); } catch (e) { console.error(`Error adding welcome node to ${moduleName}:`, e); } }

// --- Initial Execution Trigger ---
if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeApp); }
else { initializeApp(); }

// === END OF COMPLETE xocoflow_logic.js ===